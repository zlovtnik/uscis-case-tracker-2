package uscis.grpc

import cats.effect.{IO, Ref}
import cats.effect.unsafe.implicits.global
import cats.implicits._
import io.circe.syntax._
import io.circe.parser._
import io.grpc.stub.StreamObserver
import org.http4s.client.Client
import org.typelevel.log4cats.Logger
import org.typelevel.log4cats.slf4j.Slf4jLogger
import uscis.persistence.PersistenceManager
import uscis.api.{USCISClient, USCISApiClient}
import uscis.models.{CaseStatus => ModelCaseStatus, CaseHistory => ModelCaseHistory}
import uscis.proto.service._
import com.google.protobuf.timestamp.Timestamp
import java.time.{Instant, LocalDateTime, ZoneId, ZoneOffset}
import scala.concurrent.{Future, Promise}
import scala.concurrent.ExecutionContext

/**
 * Standard gRPC service implementation (Future-based) for use with Armeria.
 * 
 * This is a wrapper that bridges the IO-based logic to Future-based gRPC.
 * Implements the USCISCaseService trait generated by ScalaPB.
 */
class USCISCaseServiceGrpcImpl(
  persistence: PersistenceManager,
  httpClient: Client[IO],
  tokenCache: Ref[IO, Option[USCISApiClient.CachedToken]],
  startTime: Instant,
  zoneId: ZoneId = ZoneId.of("UTC")
)(implicit ec: ExecutionContext) extends USCISCaseServiceGrpc.USCISCaseService {

  private val logger: Logger[IO] = Slf4jLogger.getLoggerFromClass[IO](this.getClass)

  // Import circe codecs from companion objects
  import ModelCaseStatus._
  import ModelCaseHistory._

  // ============================================================
  // Converters
  // ============================================================

  private def toProtoTimestamp(ldt: LocalDateTime): Timestamp = {
    val instant = ldt.toInstant(ZoneOffset.UTC)
    Timestamp(instant.getEpochSecond, instant.getNano)
  }

  private def fromProtoTimestamp(ts: Timestamp): LocalDateTime =
    LocalDateTime.ofInstant(Instant.ofEpochSecond(ts.seconds, ts.nanos), ZoneOffset.UTC)

  private def toProtoStatus(status: ModelCaseStatus): CaseStatus =
    CaseStatus(
      receiptNumber = status.receiptNumber,
      caseType = status.caseType,
      currentStatus = status.currentStatus,
      lastUpdated = Some(toProtoTimestamp(status.lastUpdated)),
      details = status.details
    )

  private def toProtoHistory(history: ModelCaseHistory): CaseHistory =
    CaseHistory(
      receiptNumber = history.receiptNumber,
      statusUpdates = history.statusUpdates.map(toProtoStatus)
    )

  private def fromProtoStatus(status: CaseStatus): ModelCaseStatus =
    ModelCaseStatus(
      receiptNumber = status.receiptNumber,
      caseType = status.caseType,
      currentStatus = status.currentStatus,
      lastUpdated = status.lastUpdated.map(fromProtoTimestamp).getOrElse(LocalDateTime.now(ZoneOffset.UTC)),
      details = status.details
    )

  private def fromProtoHistory(history: CaseHistory): ModelCaseHistory =
    ModelCaseHistory(
      receiptNumber = history.receiptNumber,
      statusUpdates = history.statusUpdates.map(fromProtoStatus).toList
    )

  /** Convert IO to Future for gRPC compatibility */
  private def ioToFuture[A](io: IO[A]): Future[A] = io.unsafeToFuture()

  // ============================================================
  // Service Methods
  // ============================================================

  override def addCase(request: AddCaseRequest): Future[AddCaseResponse] = {
    val io = for {
      _ <- logger.info(s"AddCase request for: ${request.receiptNumber}")
      result <- if (request.fetchFromUscis) {
                  USCISClient.checkCaseStatus(httpClient, tokenCache, request.receiptNumber)
                    .flatTap(persistence.addOrUpdateCase)
                    .map(status => AddCaseResponse(success = true, caseStatus = Some(toProtoStatus(status))))
                    .handleError(e => AddCaseResponse(success = false, errorMessage = Some(e.getMessage)))
                } else {
                  // Always use UTC for timestamps to ensure consistency with proto conversions
                  val status = ModelCaseStatus(
                    receiptNumber = request.receiptNumber,
                    caseType = request.caseType.getOrElse("Unknown"),
                    currentStatus = request.currentStatus.getOrElse("Pending"),
                    lastUpdated = LocalDateTime.now(ZoneOffset.UTC),
                    details = request.details
                  )
                  persistence.addOrUpdateCase(status).as(
                    AddCaseResponse(success = true, caseStatus = Some(toProtoStatus(status)))
                  )
                }
    } yield result
    ioToFuture(io)
  }

  override def getCase(request: GetCaseRequest): Future[GetCaseResponse] = {
    val io = for {
      _ <- logger.debug(s"GetCase request for: ${request.receiptNumber}")
      maybeHistory <- persistence.getCaseByReceipt(request.receiptNumber)
    } yield GetCaseResponse(
      found = maybeHistory.isDefined,
      caseHistory = maybeHistory.map(toProtoHistory)
    )
    ioToFuture(io)
  }

  override def listCases(request: ListCasesRequest): Future[ListCasesResponse] = {
    val io = for {
      _ <- logger.debug(s"ListCases request, page: ${request.page}, pageSize: ${request.pageSize}")
      pageSize = if (request.pageSize <= 0) 20 else request.pageSize
      page = if (request.page <= 0) 1 else request.page
      offset = (page - 1) * pageSize
      cases <- persistence.getCases(
                 filter = request.receiptFilter,
                 offset = offset,
                 limit = pageSize
               )
      totalCount <- persistence.countCases(filter = request.receiptFilter)
      totalPages = (totalCount + pageSize - 1) / pageSize
    } yield ListCasesResponse(
      cases = cases.map(toProtoHistory),
      totalCount = totalCount,
      page = page,
      totalPages = totalPages
    )
    ioToFuture(io)
  }

  override def checkStatus(request: CheckStatusRequest): Future[CheckStatusResponse] = {
    val io = for {
      _ <- logger.info(s"CheckStatus request for: ${request.receiptNumber}")
      result <- USCISClient.checkCaseStatus(httpClient, tokenCache, request.receiptNumber)
                  .flatTap(status => 
                    if (request.saveToDatabase) persistence.addOrUpdateCase(status) 
                    else IO.unit
                  )
                  .map(status => CheckStatusResponse(success = true, caseStatus = Some(toProtoStatus(status))))
                  .handleError(e => CheckStatusResponse(success = false, errorMessage = Some(e.getMessage)))
    } yield result
    ioToFuture(io)
  }

  override def deleteCase(request: DeleteCaseRequest): Future[DeleteCaseResponse] = {
    val io = for {
      _ <- logger.info(s"DeleteCase request for: ${request.receiptNumber}")
      exists <- persistence.caseExists(request.receiptNumber)
      _ <- if (exists) persistence.deleteCase(request.receiptNumber) else IO.unit
    } yield DeleteCaseResponse(success = exists)
    ioToFuture(io)
  }

  override def exportCases(
    request: ExportCasesRequest,
    responseObserver: StreamObserver[ExportCasesResponse]
  ): Unit = {
    val chunkSize = if (request.chunkSize <= 0) 50 else request.chunkSize
    
    val io = for {
      _ <- logger.info(s"ExportCases request - streaming all cases, chunkSize: $chunkSize")
      cases <- persistence.getAllCases
      filteredCases = request.receiptFilter.fold(cases)(f => 
        cases.filter(_.receiptNumber.startsWith(f))
      )
      _ <- IO.delay {
             filteredCases.grouped(chunkSize).zipWithIndex.foreach { case (chunk, idx) =>
               val totalUpdates = chunk.flatMap(_.statusUpdates).size
               val jsonData = chunk.asJson.noSpaces
               val response = ExportCasesResponse(
                 jsonData = jsonData,
                 caseCount = chunk.size,
                 totalUpdates = totalUpdates,
                 chunkIndex = idx,
                 isLastChunk = idx == (filteredCases.size - 1) / chunkSize
               )
               responseObserver.onNext(response)
             }
             responseObserver.onCompleted()
           }
    } yield ()
    io.unsafeRunAsync {
      case Left(e) => responseObserver.onError(e)
      case Right(_) => ()
    }
  }

  override def importCases(
    responseObserver: StreamObserver[ImportCasesResponse]
  ): StreamObserver[ImportCasesChunk] = {
    val jsonBuffer = new StringBuilder()
    @volatile var replaceExisting = false
    
    new StreamObserver[ImportCasesChunk] {
      override def onNext(chunk: ImportCasesChunk): Unit = {
        // Read replaceExisting from first chunk
        if (chunk.chunkIndex == 0) {
          replaceExisting = chunk.replaceExisting
        }
        jsonBuffer.append(chunk.jsonData)
      }

      override def onError(t: Throwable): Unit = {
        // Non-blocking error logging
        logger.error(t)("ImportCases stream error").unsafeRunAndForget()
        responseObserver.onError(t)
      }

      override def onCompleted(): Unit = {
        // Parse accumulated JSON and import with non-blocking IO
        val importIO: IO[ImportCasesResponse] = for {
          _ <- logger.info(s"ImportCases - parsing JSON, replaceExisting: $replaceExisting")
          result <- decode[List[ModelCaseHistory]](jsonBuffer.toString()) match {
            case Right(histories) =>
              // Process all histories in parallel, tracking success/failure
              histories.parTraverse { history =>
                history.statusUpdates.lastOption.fold(IO.pure((0, 0))) { status =>
                  persistence.addOrUpdateCase(status)
                    .as((1, 0))  // success: (1, 0)
                    .handleError(_ => (0, 1))  // failure: (0, 1)
                }
              }.map { results =>
                val (successes, failures) = results.foldLeft((0, 0)) {
                  case ((sAcc, fAcc), (s, f)) => (sAcc + s, fAcc + f)
                }
                ImportCasesResponse(
                  success = failures == 0,
                  importedCount = successes,
                  errorMessage = if (failures > 0) Some(s"$failures case(s) failed to import") else None
                )
              }
            case Left(err) =>
              IO.pure(ImportCasesResponse(
                success = false,
                importedCount = 0,
                errorMessage = Some(s"JSON parse error: ${err.getMessage}")
              ))
          }
        } yield result

        // Run async, completing the stream when done
        importIO.unsafeRunAsync {
          case Left(e) => 
            responseObserver.onNext(ImportCasesResponse(
              success = false, 
              importedCount = 0,
              errorMessage = Some(e.getMessage)
            ))
            responseObserver.onCompleted()
          case Right(response) => 
            responseObserver.onNext(response)
            responseObserver.onCompleted()
        }
      }
    }
  }

  override def watchCases(
    request: WatchCasesRequest,
    responseObserver: StreamObserver[CaseUpdate]
  ): Unit = {
    // Simple implementation - check once and return
    // In production, this would use a proper pub/sub mechanism
    val io = for {
      _ <- logger.info(s"WatchCases request for: ${request.receiptNumbers.mkString(", ")}")
      // Use persistence method to filter at the data layer
      relevantCases <- if (request.receiptNumbers.isEmpty) 
                         persistence.getAllCases
                       else 
                         persistence.getCasesByReceipts(request.receiptNumbers.toList)
      _ <- IO.delay {
             relevantCases.foreach { history =>
               history.statusUpdates.lastOption.foreach { status =>
                 val update = CaseUpdate(
                   caseStatus = Some(toProtoStatus(status)),
                   updateType = UpdateType.UPDATE_TYPE_NEW,
                   timestamp = Instant.now().toString
                 )
                 responseObserver.onNext(update)
               }
             }
             responseObserver.onCompleted()
           }
    } yield ()
    io.unsafeRunAsync {
      case Left(e) => responseObserver.onError(e)
      case Right(_) => ()
    }
  }

  override def healthCheck(request: HealthCheckRequest): Future[HealthCheckResponse] = {
    val uptime = java.time.Duration.between(startTime, Instant.now()).toSeconds
    val io = persistence.countCases.map { count =>
      HealthCheckResponse(
        healthy = true,
        version = uscis.BuildInfo.version,
        uptimeSeconds = uptime,
        trackedCases = count
      )
    }
    ioToFuture(io)
  }
}
